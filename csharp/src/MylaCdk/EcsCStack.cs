using Amazon.CDK;
using Amazon.CDK.AWS.ApplicationAutoScaling;
using Amazon.CDK.AWS.CertificateManager;
using Amazon.CDK.AWS.EC2;
using Amazon.CDK.AWS.ECR;
using Amazon.CDK.AWS.ECS;
using Amazon.CDK.AWS.ECS.Patterns;
using Amazon.CDK.AWS.ElasticLoadBalancingV2;
using Amazon.CDK.AWS.IAM;
using Amazon.CDK.AWS.RDS;
using Amazon.CDK.AWS.Route53;
using Amazon.CDK.AWS.Route53.Targets;
using Constructs;
using System.Collections.Generic;

namespace MyLACdk
{
    // Add any properties that you want to pass to your stack
    public class EcsCStackProps : StackProps
    {
        public string ClientName { get; set; }
        public string EnvName { get; set; }
        public ICluster Cluster { get; set; }
        public DatabaseInstance Rds { get; set; }
        public string Hosted { get; set; }
        public string CertificateArn { get; set; }
        public string Region { get; set; }
        public IHostedZone Zone { get; set; }
    }

    public class EcsCStack : Stack
    {
        // The code that defines your CF stack goes here
        public EcsCStack(Construct scope, string id, EcsCStackProps props = null)
            : base(scope, id, props)
        {
            var clientName = props.ClientName;
            string clientPrefix = $"{clientName}{props.EnvName}";

            //get pre-populated certtifcate (pem format) values from secret store - something like vault could replace this later 
            //these are used to create the EA saml provider and EA IAM SSO certificates 
            //all these will be injected as environment variables into the container
            var samlPem = Amazon.CDK.AWS.SecretsManager.Secret.FromSecretCompleteArn(this, "samlpem", "arn:aws:secretsmanager:us-east-1:654654599146:secret:SAMLProviderPem-O3bP5m");
            var samlRsaKey = Amazon.CDK.AWS.SecretsManager.Secret.FromSecretCompleteArn(this, "samlkey", "arn:aws:secretsmanager:us-east-1:654654599146:secret:SamlRsaKey-D3R6c5");
            var providerlPem = Amazon.CDK.AWS.SecretsManager.Secret.FromSecretCompleteArn(this, "providerpem", "arn:aws:secretsmanager:us-east-1:654654599146:secret:EaPem-Y32PsR");
            var providerRsaKey = Amazon.CDK.AWS.SecretsManager.Secret.FromSecretCompleteArn(this, "providerKey", "arn:aws:secretsmanager:us-east-1:654654599146:secret:EaKey-HDhRJz");

            var taskRole = new Role(this, $"{clientPrefix}-task-role", new RoleProps
            {
                AssumedBy = new ServicePrincipal("ecs-tasks.amazonaws.com"),
                RoleName = $"{clientPrefix}-task-role",
                Description = "Role that the web task definitions use to run the myLA web app"
            });

            //get the previously autogenerated db secret
            var dbSecret = Amazon.CDK.AWS.SecretsManager.Secret.FromSecretCompleteArn(this, "db-secret", props.Rds.Secret.SecretArn);

            var repository = Repository.FromRepositoryName(this, "myla-dev", "myla-dev");
            var image = ContainerImage.FromEcrRepository(repository, "1.2");
            var cert = Certificate.FromCertificateArn(this, $"{props.Hosted}-cert", props.CertificateArn);

            var taskDef = new FargateTaskDefinition(this, $"{clientPrefix}-task-def", new FargateTaskDefinitionProps
            {
                Cpu = 512,
                MemoryLimitMiB = 1024,
                TaskRole = taskRole
            });

            taskDef.AddContainer($"{clientPrefix}-web-container", new ContainerDefinitionOptions
            {
                User = "1654", //user defined in image
                Image = image, //use the image from the ecr for now
                ContainerName = $"{clientPrefix}-web-container",
                PortMappings = new PortMapping[]
                {
                    new PortMapping
                    {
                        ContainerPort = 8443
                    }
                },
                Logging = LogDriver.AwsLogs(new AwsLogDriverProps
                {
                    StreamPrefix = $"{clientPrefix}-web-container"
                }),

                //these are the secrets that will be injected into the container as environment variables
                Secrets = new Dictionary<string, Secret>
                {
                    { "DB_PASSWORD", Secret.FromSecretsManager(dbSecret, "password")},
                    { "DB_USER", Secret.FromSecretsManager(dbSecret, "username")},
                    { "AppConfiguration__SAMLProvider__Certificate__Pem",  Secret.FromSecretsManager(samlPem) },
                    { "AppConfiguration__SAMLProvider__Certificate__RSAKey",  Secret.FromSecretsManager(samlRsaKey)},
                    { "AppConfiguration__ServiceProvider__Certificate__Pem", Secret.FromSecretsManager(providerlPem) },
                    { "AppConfiguration__ServiceProvider__Certificate__RSAKey", Secret.FromSecretsManager(providerRsaKey)}
                },
                Environment = new Dictionary<string, string>
                {
                    { "ASPNETCORE_ENVIRONMENT", "Docker" },
                    {"ASPNETCORE_URLS", "https://*:8443;http://*:8080" },
                    { "ASPNETCORE_Kestrel__Certificates__Default__Password", "1234"},
                    { "ASPNETCORE_Kestrel__Certificates__Default__Path", "/usr/local/share/ca-certificates/localhost.pfx" },
                    { "DB_HOST", props.Rds.InstanceEndpoint.Hostname},
                    { "DB_PORT", props.Rds.InstanceEndpoint.Port.ToString() },
                    { "DB_NAME", "SessionCache" }
                }
            });

            var elbFargateService = new ApplicationLoadBalancedFargateService(this, $"{clientPrefix}-ecs-service",
                    new ApplicationLoadBalancedFargateServiceProps
                    {
                        Cluster = props.Cluster,
                        Cpu = 512,
                        MemoryLimitMiB = 1024,
                        ServiceName = $"{clientPrefix}-ecs-service",
                        Certificate = cert,
                        DomainZone = props.Zone,
                        TargetProtocol = ApplicationProtocol.HTTPS,
                        LoadBalancerName = $"{clientPrefix}-elb",
                        TaskSubnets = new SubnetSelection { SubnetType = SubnetType.PRIVATE_WITH_EGRESS },
                        DesiredCount = 2,
                        CircuitBreaker = new DeploymentCircuitBreaker
                        {
                            Rollback = true
                        },
                        RedirectHTTP = true,
                        TaskDefinition = taskDef
                    });

            elbFargateService.TargetGroup.ConfigureHealthCheck(
                new Amazon.CDK.AWS.ElasticLoadBalancingV2.HealthCheck
                {
                    Path = "/hc/ready",
                    Protocol = Amazon.CDK.AWS.ElasticLoadBalancingV2.Protocol.HTTPS,
                });
            // if we want to use sticky sessions
            // elbFargateService.TargetGroup.EnableCookieStickiness(Duration.Hours(1), "MtLAAppCookie");

            var scalableTarget = elbFargateService.Service.AutoScaleTaskCount(new EnableScalingProps
            {
                MaxCapacity = 6,
                MinCapacity = 2               
            });

            //add an alias in Route53 that points to the load balancer 
            new ARecord(this, $"{props.Hosted}-ARecord", new ARecordProps
            {
                RecordName = props.Hosted,
                Target = RecordTarget.FromAlias(new LoadBalancerTarget(elbFargateService.LoadBalancer)),
                Ttl = Duration.Seconds(300),
                Comment = $"${props.EnvName} ${props.Hosted} Arecord",
                Region = props.Region,
                Zone = props.Zone
            });

            //when to scale up or down
            //scale up when cpu or memory is at 75%
            scalableTarget.ScaleOnMemoryUtilization($"{clientPrefix}-ScaleUpMem",
                new MemoryUtilizationScalingProps
                {
                    TargetUtilizationPercent = 75,
                });

            scalableTarget.ScaleOnCpuUtilization($"{clientPrefix}-ScaleUpCPU",
               new CpuUtilizationScalingProps
               {
                   TargetUtilizationPercent = 75,
               });

            // cloud formation outputs
            new CfnOutput(this, $"{props.EnvName}-serviceName", new CfnOutputProps
            {
                ExportName = $"{props.EnvName}-serviceName",
                Value = elbFargateService.Service.ServiceName
            }); 
        }
    }
}
