using Amazon.CDK;
using Amazon.CDK.AWS.EC2;
using Amazon.CDK.AWS.ECS;
using Amazon.CDK.AWS.RDS;
using Constructs;

namespace MyLACdk
{
    // Add any properties that you want to pass to your stack
    public class StateFulCProps : StackProps
    {
        public string ClientName { get; set; }
        public string EnvName { get; set; }
        public IVpc Vpc { get; set; }
        public ICluster Cluster { get; set; }
        public ICluster ClusterAnywhere { get; set; }
    }

    public class StateFulCStack : Stack
    {
        public readonly IDatabaseInstance rds;

        // The code that defines your CF stack goes here
        public StateFulCStack(Construct scope, string id, StateFulCProps props = null)
            : base(scope, id, props)
        {
            var clientName = props.ClientName;
            string clientPrefix = $"{clientName}{props.EnvName}";

            // create a security group for sql server rds db
            var dbSecurityGroup = new SecurityGroup(this, $"{clientPrefix}-db-sg", new SecurityGroupProps
            {
                Vpc = props.Vpc, // use the vpc created previously          
                AllowAllOutbound = true // allow outbound traffic to anywhere 0.0.0.0/0 
            });

            var dbport = 1433; // default ms sql server port

            dbSecurityGroup.AddIngressRule(
                Peer.AnyIpv4(),
                Port.Tcp(dbport),
                "allow inbound traffic from anywhere to the db on port 1433");
            //rds
            //look at docs to get version with instance type
            //https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.VersionSupport
            // this will create a sql server rds instance for caching
            // username and password are autogenerated and placed in the AWS secret store automatically            
            var databaseCluster = new DatabaseInstance(this, $"{clientPrefix}-rds", new DatabaseInstanceProps
            {
                Engine = DatabaseInstanceEngine.SqlServerEx(new SqlServerExInstanceEngineProps
                {
                    Version = SqlServerEngineVersion.VER_15
                }),
                Vpc = props.Vpc,
                MultiAz = false, //it ignores this and still requires it created in  a multi-az
                VpcSubnets = new SubnetSelection { Subnets = props.Vpc.PublicSubnets },
                InstanceType = Amazon.CDK.AWS.EC2.InstanceType.Of(InstanceClass.T3, InstanceSize.XLARGE),
                BackupRetention = Duration.Days(7),
                PubliclyAccessible = true,
                RemovalPolicy = RemovalPolicy.DESTROY, //retain in production
                //DatabaseName = $"{clientPrefix}-db", //cannot use this for ms sql, must be null
            });

            databaseCluster.Connections.AllowFrom(props.Cluster.Connections, Port.Tcp(dbport));
            databaseCluster.Connections.AllowFrom(props.ClusterAnywhere.Connections, Port.Tcp(dbport));
            databaseCluster.Connections.AllowDefaultPortFromAnyIpv4("Allow to 1433");

            //assign the output variables so they can be used in other stacks
            this.rds = databaseCluster;

            // cloudformation output
            new CfnOutput(this, $"{props.EnvName}-rds", new CfnOutputProps
            {
                ExportName = $"{props.EnvName}-rds-Address",
                Value = databaseCluster.DbInstanceEndpointAddress
            });
        }
    }
}
